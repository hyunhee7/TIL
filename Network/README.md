# Network

아래 내용은 https://net123.tistory.com/384?category=605873 를 통해 공부하고 정리한 내용입니다.

## 프로토콜
* 데이터 전송 시 필요한 규칙 및 약속을 미리 정의한 도구
* 네트워크가 구성되기 이전에 미리 정의되거나 관리자에 의해 선택되어야 한다.

그럼 프로토콜 어떻게 사용할까?

## 인캡슐레이션
데이터 보내기 위해 포장하는 과정

* HTTP 보내기 위해 TCP라는 프로토콜 사용
* 위에 것을 보내려면 IP 사용
* 위에 것 보내려면 Ethernet 사용

	Ethernet | IP | TCP | HTTP
    
* 헤더 : Ethernet, IP, TCP
	이런식으로 전송을 위해 붙는 프로토콜을 '헤더'라고 한다. 헤더 정보 속 주소를 보고 도착지로 움직인다.
    
* HTTP
    * TCP 헤더 20byte
    * IP 헤더 20byte
    * Ethernet 헤더 14byte

* DNS
    * UDP
    * IP
    * Ethernet

## 네트워크 유형

### LAN(Local Area Network)
* 전송 장비
	* 허브
	* 스위치
	* 케이블(랜선)
	* 무선 공유기

* 데이터 전송 프로토콜 
	* Ethernet (안에서 이동하게 쓰는 것)
		출발지 MAC주소, 도착지 MAC주소, type(내부 들어있는 데이터 타입)

### WAN(Wide Area Network)
연결되는 거리가 멀다. LAN과 LAN을 연결한다.
ISP업체를 통해 연결. 인터넷과 네트워크망을 임대해주는 업체. WAN은 일반적으로 ISP를 통해서 연결된다. 대표적인 ISP로는 KT, SK, LG가 있다.

* 사용 프로토콜
	* HDLC (기본값)
	* frame-relay
	* PPP
	* 요즘에는 Ethernet 사용, 구분이 없음.
		* FastEthernet 100M
		* GigabitEthernet 1000M
		* 10GigabitEthernet 10000M

* 관리는 ISP업체가 담당한다. 


### 인터넷
* 전세계적으로 연결된 네트워크 망 서비스
* TCP/IP가 반드시 필요

### Intranet
* 기업 내부용으로 사용하는 네트워크 서비스
* 회사 게시판, 공지사항, 자료 공유 ...

## 데이터 요청 관계

### 서버(Server)
클라이언트로부터 요청된 정보를 수신

### 클라이언트(Client)
서버에게 데이터를 요청 실시

### 데이터 전송 방식
* 대역폭 10M 라면?
* 가장 많이 사용하는 것은 유니테스트

#### 유니테스트
* 일대일 데이터 전송
* 대역폭을 늘려야만 고객 수용 가능
* 1M 데이터 전송하려면 100명에게 동시 전송 불가능
* 예 : 생방송 중 나는 처음부터 보려고 할 때

#### 브로드케스트
* 일대다 데이터 전송(전체)
* 서버에서는 한개만 전송, 스위치에서 복제 후 전송
* 대역폭 증설 필요가 없음
* 내부 네트워크에서만 주로 사용
* LAN 네트워크 성능이 저하
* 라우터가 받으면 다른 네트워크로는 내보내지 않음

#### 멀티케스트
* 일대다 데이터 전송(그룹)
* 특정 그룹한테만 데이터 전송
* 예: 유료 결제 고객에게만 데이터를 전송
	* VOD서비스: 결제한 고객만 전송

## OSI 7계층

## TCP와 UDP
[참고 : TCP와 UDP 차이점](https://mangkyu.tistory.com/15) 

### 공통점
* 네트워크 계층 중 전송 계층에서 사용하는 프로토콜

### 차이점
#### TCP 
* 흐름제어 및 혼잡제어 제공
* 높은 신뢰성
* UDP보다 낮은 속도
* **3-way handshaking** 과정을 통해 연결 

#### UDP 
* 데이터그램 단위로 처리하는 프로토콜
* 비연결형 서비스
* 낮은 신뢰성
* TCP보다 빠른 속도
* 신뢰성보다 연속성이 중요한 서비스(ex.스트리밍 서비스)에 많이 이용

## TCP를 이용한 통신 과정
### 3-way handshaking
TCP를 사용한 데이터 송수신 간의 정확한 전송을 보장하기 위한 **세션 수립 과정**
##### 1. 클라이언트가 서버에게 요청 세그먼트 전송
송신자가 최초로 데이터를 전송할 때 Sequence Number를 임의의 랜덤 숫자로 지정
SYN 플래그 비트를 1로 설정해서 전송

    Flag : SYN
    PORT : Client(CLOSED),Server(Listen)
##### 2. 서버가 클라이언트의 요청을 받아들이는 세그먼트 전송, 클라이언트로 향하는 트래픽에 대한 초기화 정보를 포함하는 세그먼트를 전송
수신자는 Acknowledgement Number 필드를 Sequence Number+1로 지정
SYN과 ACK 플래그 비트 1로 설정해서 전송

    Flag : SYN + ACK
    PORT : Client(CLOSED),Server(SYN_RCV)
##### 3. 클라이언트는 이를 응답하는 세그먼트 전송
마지막 접속 요청 프로세스 A가 수락 확인을 보내 연결 맺음
전송 데이터가 있을 경우, 이때 전송

	PORT : Client(ESTABLISHED), Server(SYN_RCV)
    Flag : ACK
	PORT : Client(ESTABLISHED), Server(ESTABLISHED)

### 4-way handshaking
TCP를 사용한 데이터 송수신 간의 정확한 전송을 보장하기 위한 **세션 종료 과정**
##### 1. 클라이언트는 연결 종료를 알리는 세그먼트 전송
	Flag : FIN, ACK
    FIN:1 A:0
##### 2. 서버는 클라이언트의 요구를 확인하는 세그먼트 전송
    Flag : ACK
    ACK:1
서버는 클라이언트로 데이터를 계속 전송
한 방향의 연결은 종료되나, 다른 방향 연결은 유지

##### 3. 서버가 자신의 데이터 전송 완료하면, 서버가 연결 해지 세그먼트 전송
	Flag:FIN,ACK
    FIN:1, ACK:1
##### 4. 클라이언트는 서버의 요청에 확인 응답
	Flag:ACK
    ACK:1
    
## HTTP 와 HTTPS
### HTTP 프로토콜이란?
웹 상에서 클라이언트와 서버간의 요청/응답으로 정보를 주고 받을 수 있는 프로토콜
* TCP와 UDP를 사용
* 80번 포트를 사용
* 비연결성(Connectionless) : 클라이언트의 요청 후, 서버가 클라이언트로 응답을 보내면 바로 연결이 끊긴다.
* 무상태성(Stateless) : 연결을 끊는 순간 통신이 끝나며, 상태 정보를 유지하지 않는다.

### HTTP 헤더
참고 : [HTTP헤더](https://goddaehee.tistory.com/169)

#### 공통 헤더
1. Date
	HTTP 메세지가 만들어진 시각
2. Connection
	일반적으로 HTTP/1.1 사용
3. Content-Length
	요청 및 응답 메세지의 본문 크기를 바이트 단위로 표시
4. Cache-Control
	캐싱 정책을 정의(참고: [캐싱](https://goddaehee.tistory.com/171))
5. Content-Type
	컨텐츠 타입과 문자열 인코딩 등 명시
    
#### 요청헤더
1. Host
	서버의 도메인 네임, Host 헤더는 반드시 하나가 존재해야 한다.
2. User-Agent
	현재 사용자가 어떤 클라이언트 통해 요청을 보냈는지 알 수 있다.
    (EX : Window, 크롬 브라우저 등등..)
3. Accept
	클라이언트가 허용할 수 있는 파일 형식
4. Cookie
	웹 서버가 클라이언트에 쿠키 저장 했다면, 해당 쿠키 정보를 이름-값 쌍으로 웹 서버에 전송한다.
5. Origin
	POST 요청 전송 시, 요청이 어느 주소에서 시작되었는지 나타낸다.
    요청을 보낸 주소, 받는 주소가 다를 경우 **CORS 에러** 발생
6. If-Modified-Since
	페이지 수정되었을 때 최신 버전 페이지 요청을 위한 필드
    변경되지 않았다면 전송받지 않음
7. Authorization
	인증 토큰을 서버로 보낼 때 사용하는 헤더
    JWT를 사용한 인증에서 주로 사용

#### 응답헤더
1. Server
	웹 서버 정보를 나타낸다.
2. Access-Control-Allow-Origin
	요청 HOST와 응답 HOST가 다를 때, 서버에서 이곳에 프론트 주소를 적어주면 CORS에러가 발생하지 않는다.
3. Allow
	이곳은 CORS 요청 외에도 적용
    Allow:GET 일 경우, GET요청만 받는다. POST일 경우 405 Method Not Allowed 에러 return
4. Content-Disposition
	응답 본문을 브라우저가 어떻게 표시해야할지 알려주는 헤더
    * inline : 웹 페이지 화면에 표시
    * attachment : 다운로드
5. Location
	300번대 응답, 201 Created 응답일 때, 어느 페이지로 이동할지 알려주는 헤더
    EX : HTTP/1.1 302 Found, Location:/login : 302 응답 시 /login 주소로 리다이렉트, 로그인 하지 않고 특정 페이지 접속 시 로그인 페이지로 리다이렉트
6. Content-Security-Policy
	외부 파일 불러오는 경우, 차단할 소스와 불러올 소스를 명시(이미지, JS, CSS 등)


### HTTPS 프로토콜이란?
HTTP의 보안이 강회된 버전의 프로토콜
* HTTPS의 기본 TCP/IP 포트로 443번 포트를 사용
* 소켓 통신에서 일반 텍스트를 사용하며, 웹 상에서 정보를 암호화하는 **SSL** 이나 **TLS** 프로토콜을 통해 세션 데이터를 암호화한다.

#### HTTPS의 원리
공개키 알고리즘 방식
* 공개키 : 모두에게 공개하는 키, 공개키 저장소에 등록
* 개인키 : 개인에게만 공개. 클라이언트-서버 구조에서 서버가 가지고 있는 비공개키


	1. 사용자의 데이터를 공개키로 암호화
	2. 서버로 전송
	3. 서버의 개인키를 통해 복호화하여 요청 처리

#### HTTPS의 장단점
* 장점 : 안전하다
* 단점
	1. 암호화 과정이 웹서버에 부하를 준다.
	2. 설치, 인증서 유지에 추가 비용
	3. 느리다
	4. 연결 끊긴 경우 재인증 시간 소요

## HTTP 캐싱 처리
참고: [캐싱 처리](https://goddaehee.tistory.com/171)
### 웹 서버 캐싱 처리 과정
1. 웹에 요청 호출
2. 웹 브라우저, 인터넷을 거쳐 웹 서버로 전달
	디스크의 파일 시스템에서 정적 리소스 제공
3. 첫 요청 시, 하드 디스크는 캐시를 확인하고 캐시 미스(Cache miss)를 발생 시킨다. 또한, 추후 다시 요청 받을 수 있는 경우 캐시를 하드 디스크에 저장
4. 이후 요청 시, 캐시 사용 가능하면 캐시 히트(Cache hit)를 발생시켜 캐시 미스 발생 전까지 버퍼에서 캐시가 제공

### HTTP 헤더를 통한 브라우저 캐싱
* HTML, 자바스크립트 파일, 이미지 같은 웹 문서의 임시 저장을 위해 이용
* 요청이 전송되지 않아 왕복 시간이 발생하지 않는다.
* 로컬 캐시로부터 데이터가 로드되어 빠르다.


## 메모이제이션
* 컴퓨터 프로그램이 동일 계산 반복 시, 이전 계산 값을 메모리에 저장하여 실행
* 반복 수행을 제거하여 실행 속도를 빠르게 하는 기술
* 캐싱의 한 형태
* 드물게 요청되는 함수나 빠른 응답 속도의 함수는 부적합

## CORS
웹 서버에게 보안 Cross-domain 데이터 전송을 활성화하는 Cross-domain 접근 제어권을 부여한다.
#### 과정
	1. CORS 요청 시에는 미리 OPTIONS 주소로 서버가 CORS를 허용하는지 물어본다.
	2. 이 때, Access-Control-Request-Moethod로 실제 보내고자 하는 메서드를 알린다.
	3.  Access-Control-Request-Headers로 실제 보내고자 하는 헤더들을 알린다.
	4.  Request와 Allow가 일치하면 CORS 요청이 이루어진다.

## Socket통신과 Http통신
[참고 : Socket통신과 Http통신 차이점](https://mangkyu.tistory.com/15)

### HTTP통신
Client의 요청(Request)이 있을 때만 서버가 응답(Response)하여 해당 정보를 전송하고 곧바로 연결을 종료하는 방식
#### 특징
* 단방향 통신 : Client가 요청을 보낸 경우만 Server가 응답
* Server의 응답 받은 후 연결 종료
* 필요한 경우에만 Server로 요청 보내는 상황

### Socket통신
Server와 Client가 특정 Port를 통해 실시간으로 양방향 통신하는 방식
#### 특징
* 양방향 통신 : Server와 Client가 계속 연결을 유지
* 실시간으로 데이터를 주고받는 상황이 필요한 경우 사용
* 실시간 Streaming, 온라인 게임 등에 자주 사용

## 쿠키와 세션
### 쿠키와 세션의 필요성
HTTP 프로토콜에서 상태를 유지하기 위한 기술

* HTTP 프로토콜은 비연결 지향, Stateless로 요청 간 의존관계가 없다
* 같은 사용자인지 확인이 불가능하다
* 통신 마다 새로운 연결로 인해 요청마다 인증을 해야한다.
* 같은 사용자일 경우 상태 유지가 필요

### 쿠키
#### 쿠키란
* 클라이언트 로컬에 저장되는 키와 값이 들어있는 파일
* 이름, 값, 유효 시간, 경로 등의 정보가 기록
* 클라이언트의 상태 정보를 **브라우저**에 저장하여 참조
* 사용 예 : 아이디/비밀번호 저장, 쇼핑몰 장바구니

#### 구성 요소
쿠키의 이름, 쿠키의 값, 쿠키 만료 시간, 쿠키를 전송할 도메인 이름, 전송할 경로, 보안 여부, HTTPOnly

#### 동작 방식
	1. 웹 브라우저가 서버에 요청
	2. 상태 유지하고 싶은 값을 쿠키로 생성
	3. 서버가 응답할 때, HTTP 헤더에 쿠키를 포함하여 전송
	4. 전달받은 쿠키는 웹브라우저에서 관리하고 있다가, 다음 요청 때 쿠키를 hTTP 헤더에 넣어 전송
	5. 서버에서 쿠키 정보 읽어 이전 상태 정보 확인 후 응답

### 세션
#### 세션이란
* 일정 시간 동안 같은 브라우저로부터 들어오는 요청을 하나의 상태로 간주하고, 이를 유지하는 기술

#### 동작 방식
	1. 웹 브라우저가 서버에 요청
	2. 서버가 해당 웹 브라우저에 Session ID 부여
	3. 서버가 응답할 때, HTTP 헤더에 Session ID 포함하여 전송
	4. 웹 브라우저는 브라우저 닫기 전까지 Session ID 담긴 쿠키를 HTTP 헤더에 넣어 전송
	5. 서버는 Session ID 확인 후, 해당 세션에 관련된 정보 확인한 후 응답

### 세션과 쿠키의 차이점
| 종류 | 쿠키 | 세션 |
|--------|--------|
|저장위치| 클라이언트|서버|
| 보안  |취약|비교적 좋음|
| 라이프사이클   |만료 시간에 따라 브라우저 종료해도 남아있을 수 있다.|브라우저 종료 시 삭제|
|속도|빠르다|느리다|


### 쿠키와 캐시의 차이점
참고 : [캐시와 쿠키의 차이점](https://zorba91.tistory.com/163)