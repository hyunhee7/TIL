# 객체지향 쿼리 언어 소개

## JPQL이 왜 필요할까
* 엔티티 객체 위주의 개발을 하는 JPA
* 모든 데이터를 객체화해서 **검색**을 하는 것은 불가능
* 그래서 필요한 것이 JPQL

## JPQL이란
* SQL을 추상화한 JPQL이라는 객체지향 쿼리
* SQL과 문법 유사하고, SELECT, FROM, WHERE, HAVING, GROUP BY, JOIN 지원
* 엔티티 객체를 대상으로 쿼리 

## 동적 쿼리 생성을 위한 방법
### Criteria 란 (동적쿼리 작성)
* JPQL 빌더 역할
* JPQL은 단순히 String 값이기 때문에 동적쿼리 작성이 어려움
* 자바 표준 문법
* SQL스럽지않아 복잡하고 실용성 없음 
* 유지보수가 힘들어 잘 사용하지 않는다.
* QueryDSL 권장
````java
CriteriaBuilder cb = em.getCriteriaBuilder();
CriteriaQuery<Member> query = cb.createQuery(Member.class);

Root<Member> m = query.from(Member.class);
CriteriaQuery<Member> cq = query.select(m).where(cb.equal(m.get("username", "Kim"));
List<Member> resultList = em.createQuery(cq).getResultList();
````
### QueryDSL 
* JPQL 빌더 역할 
* 컴파일 시점에 문법 오류 발견 가능
* 동적 쿼리 작성 편리
* 단순하고 쉬움
* 실무 사용 권장

### 네이티브 SQL 
* jpa가 제공하는 sql을 직접 사용 가능
* JPQL로 해결할 수 없는 특정 데이터베이스에 의존적인 기능

### jdbc 직접 사용, SpringJDBC 등
* JPA 사용하면서 JDBC 커넥션을 사용하거나, 스프링 jdbc 템플릿, 마이바티스 등을 함께 사용 가능
* JPA랑 관련이 없어서, 영속성 컨텍스트를 적절한 시점에 강제 플러시 필요

# JPQL 기본 문법과 쿼리 API
## JPQL 문법
* Select m from Member as m where m.age>18
* JPQL 키워드는 대소문자 구분 없음
* 엔티티, 속성은 대소문자 구분 있음
* 엔티티 이름 사용, 테이블 이름 아님
* 별칭은 필수(m), as는 생략 가능 

## TypeQuery, Query
* TypeQuery : 반환 타입이 명확할때 사용
* Query : 반환 타입이 명확하지 않을 때 사용
````java
TypeQuery<Member> query = em.createQuery("select m from Member m", Member.class);
Query<Member> query = em.createQuery("select m.username, m.age from Member m");
````
## 결과 조회 API
* query.getResultList() : 결과가 하나 이상일 때, 리스트 반환
* query.getSingleResultList() : 결과가 정확히 하나, 단일 객체 반환
    - 결과가 없으면 : NoResultException
    - 결과 둘 이상 : NonUniqueResultException

## 파라미터 바인딩 - 이름 기준, 위치 기준
````java
SELECT m FROM Member m where m.username=:username
query.setParameter("username",userNameParam);

````

# 프로젝션
Select 절에 조회할 대상을 지정하는 것
* 프로젝션 대상 : 엔티티, 임베디드 타입, 스칼라 타입(숫자, 문자등 기본 데이터 타입)
* Select m From Member m : 엔티티 프로젝션
* Select m.team From Member m : 엔티티 프로젝션
* Select m.address From Member m : 임베디드 타입 프로젝션
* Select m.username, m.age From Member m : 스칼라 타입 프로젝션
* Distinct 로 중복 제