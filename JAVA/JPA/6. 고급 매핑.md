

# 상속관계 매핑

## 상속관계 매핑이란?
객체의 상속 구조와 DB의 슈퍼타입, 서브타입 구조를 매핑시키는 것
슈퍼타입, 서브타입 논리 모델을 실제 물리 모델로 구현하는 방법

보통 현업에서 조인 전략을 기본으로 사용하고, 정말 단순한 경우 단일 테이블 전략 활용

## 구현 방법
### 조인전략 
각각 테이블로 변환하는 방식 (객체랑 잘 맞아 정석 방법이라고 봐야함)
#### 장점
* 정규화가 되어있다.
* 외래키 참조 무결성 제약조건 활용 가능
* 저장공간의 효율화
#### 단점
* 조회 쿼리가 복잡
* 조인 사용이 많아 성능 저하
* 데이터 저장 시, INSERT SQL 2번 호출
* 단일 테이블에 비해 관리 복잡

### 단일 테이블 전략
* 통합 테이블로 변환
* 구분자 DTYPE을 넣어서 객체 종류를 구분
#### 장점
* 조인이 필요없어서 조회 성능이 빠름
* 조회 쿼리가 단순 
#### 단점
* 자식 엔티티가 매핑한 칼럼은 null 허용해야함
* 데이터 많아지면 조회 성능 오히려 낮아질 수 있음

### 구현 클래스마다 테이블 전략
* 구현 클래스에 추상 클래스 값들을 다 넣는다
#### 장점
* 서브 타입을 명확하게 구분해서 처리할 때 효과적
* not null 제약조건 사용 가
#### 단점
* 여러 자식 테이블 조회할 때 성능 느림 (UNION의 빈번한 사용)
* 자식 테이블 통합해서 쿼리쓰기 어려움
* 이건 쓰면 안되는 전략(DBA, ORM 전문가 모두가 추천하지 않는 전략)

## 주요 어노테이션
> @Inheritance(strategy=InheritanceType.XXX)

* JOINED : 조인전략
* SINGLE_TABLE : 단일 테이블 전략
* TABLE_PER_CLASS : 구현 클래스마다 테이블 전략

> @DiscriminatorColumn(name="DTYPE")
* 하위 클래스를 구분하는 용도의 컬럼

> @DiscriminateValue("XXX")
* 엔티티를 저장할 때 슈퍼타입의 구분 컬럼에 저장할 값을 지정한다.

# Mapped SuperClass
공통 매핑 정보가 필요할 때 사용한다. (Ex. Id, name, createdDate, modifiedDate ...)
* 상속 관계 매핑이 아님
* 엔티티 아님, 테이블과 매핑 아님
* 부모 클래스를 상속받는 자식 클래스에 매핑 정보만 제공
* 조회, 검색 불가(em.find()로 baseEntity값 조회 불가)
* 직접 사용할 일 없으므로, 추상 클래스로 작성 권