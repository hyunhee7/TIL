# JPA 내부 구조

> 중요 사항

1. 객체와 관계형 데이터베이스 매핑
2. 영속성 컨텍스트

## 영속성 컨텍스트
### 엔티티 매니저 팩토리와 엔티티 매니저
요청이 올 때마다 엔티티 매니저가 생성됨

### 영속성 컨텍스트
* JPA 이해 시, 가장 중요한 용어
* 엔티티를 영구 저장하는 환경
* EntityManager.persist(entity); //DB 저장이 아닌, 영속성 컨텍스트에 저장하는 것임.
* 엔티티 매니저를 통해 영속성 컨텍스트에 접근

### 영속성 컨텍스트의 특징
#### 1차캐시를 갖고 있다.
1. 영속성 컨텍스트는 1차 캐시에서 조회 
2. 없으면 DB에서 조회
3. 1차 캐시에 저장
4. 반환

cf. 1차캐시는 한 트랜잭션에서만 효과가 있기 때문에 성능적 측면에서 그리 큰 효과를 주진 못한다.

#### 영속성 컨텍스트의 동일성 보장
1차캐시가 있기 때문에, 같은 트랜잭션 내에서 == 비교시 true로 리턴한다.

#### 트랜잭션을 지원하는 쓰기 지연 (Insert)
1. 1차캐시에 정보 등록
2. INSERT 쿼리 생성
3. 영속성 컨텍스트에 차곡차곡 쌓인다.
4. transaction.commit() 시 쿼리 실행
* 왜 이렇게 할까?
    - 버퍼링을 모아서 write하여 성능적인 측면 고려 가능
    - `<property name="hibernate.jdbc.batch_size" value="10"/>` 추가 시, 특정 갯수 모아놨다가 write 가능
    
#### 변경 감지 (Update)
1. flush()
2. 커밋되는 시점에 JPA가 엔티티와 스냅샷 비교
3. UPDATE 쿼리를 쓰기 지연 SQL 저장소에 저장
4. 반영

## 엔티티의 생명 주기
비영속, 영속, 준영속, 삭제 주기가 있다.


> 비영속 (new/transient)

영속성 컨텍스트와 전혀 관계 없는 상태
````java
Member member = new Member();
member.setId(10L);
member.setName("HelloJPA"); // 비영속 상태
````

> 영속 (managed)

영속성 컨텍스트에 관리되는 상태
````java
em.persist(member); // 영속상태 - 관리 시작 (DB 저장되지는 않음)
````

> 준영속 (detached)

영속성 컨텍스트에 저장되었다가 분리된 상태
````java
em.detach(member); //관계가 없어짐
````


> 삭제 (removed)

삭제된 상태 - 실제 DB 삭제를 요청했을 때 발생 
````java
em.remove(member);
````
