# JPA?
* Java Persistence API
* ORM(Object-Relational Mapping) 프레임워크
* CRUD SQL을 알아서 처리하고, 객체 모델링과 관계형 데이터베이스 사이의 차이점을 해결
* 객체 중심 개발로 인해, 생산성과 유지보수가 좋아진다.

## 패러다임의 불일치
JPA는 관계형 데이터베이스와 객체의 패러다임 불일치를 해결하는 중간 다리 역할을 한다.

### 지향 목적이 다르다.
* 관계형 데이터베이스 : 데이터 중심으로 구조화되어 있다. 집합적 사고를 요구한다.
* 객체 : 객체 지향의 중심인 추상화, 상속, 다형성이 중요하다. 이는 관계형 데이터베이스에 없는 개념이다.

# 영속성 관리
## 엔티티 매니저 팩토리와 엔티티 매니저
### 엔티티 매니저 팩토리
* 엔티티 매니저를 만드는 공장
* 한개만 만들어 애플리케이션 전체에서 공유하도록 설계(생성 비용이 커서)
* 여러 스레드가 동시 접근해도 안전하여 다른 스레드간 공유 가능
### 엔티티 매니저
* 엔티티를 저장, 수정, 삭제, 조회하는 등 엔티티와 관련된 모든 일 처리
* 엔티티 저장하는 가상 데이터베이스
* 여러 스레드가 동시 접근하면 동시성 문제 발생하므로, 스레드간 공유 불가능

## 영속성 컨텍스트(Persistence context)
* 엔티티를 영구 저장하는 환경
* 엔티티 매니저로 엔티티 저장, 조회 시 영속성 컨텍스트에 엔티티 보관 및 관리

## 엔티티 생명주기
![entityLifecycle](https://ultrakain.gitbooks.io/jpa/content/chapter3/images/JPA_3_2.png)
    
 4가지 상태가 있다
* 비영속(new/transient) : 영속성 컨텍스트와 전혀 관계가 없는 상태
* 영속(managed) : 영속성 컨텍스트에 저장된 상태
* 준영속(detached) : 영속성 컨텍스트에 저장되었다가 분리된 상태
* 삭제(removed) : 삭제된 상태

## 영속성 컨텍스트 특징
1. 식별자 값으로 엔티티를 구분하므로, 식별자 값이 반드시 있어야 한다.(테이블의 기본키와 맵핑한 값)
2. 트랜젝션 커밋하는 순간 영속성 컨텍스트에 새로 저장된 엔티티를 DB에 반영(flush)
3. 아래와 같은 장점
    * 1차 캐시
    * 동일성 보장
    * 트랜젝션을 지원하는 쓰기 지연
    * 변경 감지
    * 지연 로딩
    
### 엔티티 조회
* 영속성 컨텍스트 내부에 1차 캐시가 있다. 
* 영속 상태 엔티티는 모두 이곳에 저장한다.
* 쉽게 말하면, 영속성 컨텍스트에는 Map이 있는데 key는 기본키, value는 엔티티 인스턴스.

1. 1차 캐시에서 조회를 한다.
2. 1차 캐시에 없으면 데이터베이스에서 조회한다.

#### 영속 엔티티의 동일성 보장
````java
Member a = em.find(Member.class, "member1");
Member b = em.find(Member.class, "member1");
````
여기서 a==b 일까?
정답은 true. 영속성 컨텍스트는 1차 캐시에 있는 같은 엔티티 인스턴스를 반환한다. 엔티티의 동일성을 보장한다.

> cf. 동일성 vs 동등성
* 동일성(identity) : 실제 인스턴스가 같다. 따라서 참조 값 비교하는 == 비교의 값이 같음.
* 동등성(equality) : 실제 인스턴스는 다를 수 있으나, 인스턴스의 값은 같음. equals() 메소드.

### 엔티티 등록
1. 트랜잭션 커밋 직전까지 내부 쿼리 저장소에 INSERT SQL 쌓아 놓음.
2. 트랜잭션 커밋 시, DB에 보낸다. (**쓰기지연**, transactional write-behind)

### 엔티티 수정

* 엔티티 모든 필드를 업데이트
* 수정 쿼리가 항상 같아, 미리 생성해두고 재사용 가능
* 동일 쿼리 보내면 DB는 이전에 한 번 파싱한 쿼리 재사용 가능
* hibernate 확장 기능으로 동적인 SQL 생성 가능

#### 과정
> 변경감지는 영속성 컨텍스트가 관리하는 영속 상태의 엔티티에만 적용된다.
1. 트랜잭션 커밋하면 엔티티 매니저 내부에서 flush()가 호출된다.
2. 최초 상태를 복사해둔 스냅샷과 엔티티를 비교하여 변경된 엔티티 찾는다. (변경 감지, dirty checking)
3. 변경된 엔티티 존재하면, 수정 쿼리 생성해서 쓰기 지연 SQL 저장소에 보낸다.
4. 쓰기 지연 저장소의 SQL을 데이터베이스에 보낸다.
5. 데이터베이스 트랜잭션을 커밋한다.



### 엔티티 삭제
1. 삭제 대상 엔티티를 넘겨준다.
2. 쓰기 지연 SQL 저장소에 등록
3. 실제 데이터베이스에 삭제 쿼리 전달
4. 영속성 컨텍스트에서 제거

## 플러시(flush())
영속성 컨텍스트의 변경 내용을 데이터베이스에 반영
### 방법
* em.flush() 직접호출
* 트랜잭션 커밋 시, 플러시 자동 호출
* JPQL(java persistence query language) 쿼리 실행 시, 플러시 자동 호출

## 준영속
> 영속성 컨텍스트에서 분리된 상태
* 영속성 컨텍스트가 제공하는 기능을 사용할 수 없다.

### 영속에서 준영속
#### 방법
* em.detach(entity) : 특정 엔티티만 준영속 상태로 전환
* em.clear() : 영속성 컨텍스트를 완전히 초기화
* em.close() : 영속성 컨텍스트를 종료

### 준영속에서 영속
#### 방법
* merge() : 준영속 상태의 엔티티를 받아서 새로운 영속 상태의 엔티티를 반환

# 엔티티 맵핑
## @Entity
이 어노테이션이 붙은 클래스는 JPA가 관리하는 것으로, 엔티티라 부른다.
## @Table
Table은 엔티티와 매핑할 테이블을 지정한다.
## 데이터베이스 스키마 자동 생성
아래 속성 추가 시, 애플리케이션 실행 시점에 데이터베이스 테이블을 자동으로 생성한다.

그러나, 운영 환경에서 사용할 만큼 완벽하지는 않기 때문에 개발 환경이나 맵핑에 대해 참고하는 정도로만 사용하는 것이 좋다.
````java
<property name="hibernate.hbm2ddl.auto" value="create"/>
````
* create : Drop + Create
* create-drop : Drop + Create + Drop
* update : 변경 사항만 수정
* validate : 데이터베이스 테이블과 엔티티 매핑정보 비교하여 차이있으면 경고 남기고, 애플리케이션을 실행하지 않는다.
* none : 사용 안할 때

## DDL 생성 기능
DDL 자동 생성할 때만 사용될 뿐, JPA 실행 로직에는 영향 주지 않는다.
* Nullable, length
````
@Column(name = "NAME", nullable = false, length = 10)
````
* 유니크 제약조건
````
@Table(name="MEMBER", uniqueConstraints = {@UniqueConstraint (
        name="NAME_AGE_UNIQUE",    
        columnNames={"NAME","AGE"})
        })
````

## 기본 키 매핑
* 직접 할당 : 기본 키를 애플리케이션에 직접 할당
* 자동 생성 : 대리 키 사용 방식
    1. IDENTITY : 기본 키 생성을 데이터베이스에 위임한다.
    2. SEQUENCE : 데이터베이스 시퀀스를 사용해서 기본 키를 할당한다.
    3. TABLE : 키 생성 테이블을 사용한다.

### 기본키 직접 할당 전략
@Id로 매핑하면 된다.
````
Board board = new Board();
board.setId("id1");
em.persist(board);
````

### IDENTITY 전략
* 기본 키 생성을 데이터베이스에 위임하는 전략
* MySQL, PostgreSQL, SQL Server, DB2 에서 사용
